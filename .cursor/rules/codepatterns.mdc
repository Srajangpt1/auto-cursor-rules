---
description: Code style conventions and patterns used throughout the TypeScript codebase
globs: ["**/*.ts","**/*.js"]
alwaysApply: false
---

- **Indentation Style**: Use 2 spaces for indentation, never tabs. All code files consistently use 2-space indentation.
  - function example() {
  const value = 1;
  return value;
}
  - if (condition) {
  doSomething();
}

- **Naming Conventions**: Use camelCase for functions, variables, and method names. Use PascalCase for interfaces, types, classes, and exported types. Use descriptive, clear names that indicate purpose.
  - camelCase: generateRules, checkCursorAgent, readExistingRules
  - PascalCase: GenerateRulesConfig, AnalysisResult, CursorAgentCheck, RuleCategory

- **Function Documentation**: All exported functions must have JSDoc-style comments with /** */ syntax. Include a brief description of what the function does. Document parameters and return types in TypeScript types, not JSDoc tags.
  - /**
 * Check if cursor-agent is installed and accessible
 */
export async function checkCursorAgent(): Promise<CursorAgentCheck>
  - /**
 * Main function to generate cursor rules
 */
export async function generateRules(config: GenerateRulesConfig = {}): Promise<RulesManagerResult>

- **Import Organization**: Group imports logically: Node.js built-ins first (if any), then external dependencies, then local imports. Use named imports for clarity. Keep import statements at the top of the file.
  - import { spawn } from 'child_process';
import chalk from 'chalk';
import { Command } from 'commander';
import { generateRules } from './index';
  - import * as fs from 'fs';
import * as path from 'path';
import { AnalysisData, RulesManagerResult } from './types';

- **Export Patterns**: Use named exports (export function, export const) rather than default exports. Export types and interfaces explicitly using export interface/export type. Re-export related items from index.ts using export *.
  - export async function generateRules(...) { }
  - export interface GenerateRulesConfig { }
  - export * from './types';

- **File Organization**: One major concern per file. Related functions grouped together. Files named with kebab-case for multi-word names (e.g., rules-manager.ts), single words can use camelCase. Each file should have a clear, singular responsibility.
  - src/analyzer.ts - handles cursor-agent integration
  - src/rules-manager.ts - handles file system operations for rules
  - src/cli.ts - handles CLI interface

- **Code Formatting**: Use consistent spacing around operators, after commas, and in object literals. Use trailing commas in multiline arrays and objects. Use semicolons at end of statements.
  - const config: GenerateRulesConfig = {
  outputDir: options.output,
  verbose: options.verbose,
  dryRun: options.dryRun,
};
  - const files = ['file1', 'file2', 'file3'];

- **String Literals**: Use single quotes for string literals throughout the codebase. Use template literals (backticks) for multi-line strings and string interpolation.
  - const message = 'Simple string';
  - const path = path.join(baseDir, '.cursor', 'rules');
  - const prompt = `Analyze this entire codebase...`;

- **Conditional Logic**: Prefer early returns for error conditions. Use explicit boolean checks (=== true, === false) when clarity is needed. Use optional chaining and nullish coalescing where appropriate.
  - if (!agentCheck.installed) {
  return { success: false, error: '...' };
}
  - const alwaysApply = category.alwaysApply !== undefined ? category.alwaysApply : category.ruleType === 'always' ? true : false;

- **CLI Error Handling**: In CLI entry points (cli.ts), use process.exit() with appropriate exit codes (1 for errors, 0 for success) after displaying error messages. Library functions should return error objects instead of exiting.
  - if (!agentCheck.installed) {
  console.error(chalk.red('Error: ...'));
  process.exit(1);
}
  - // In library functions, return errors instead:
return { success: false, error: '...' };

- **Filename Comparison**: When comparing filenames for existence checks, use case-insensitive comparison by converting to lowercase. This prevents issues with case-sensitive file systems while maintaining compatibility.
  - const existingFilenames = new Set(existingRules.map((r) => r.filename.toLowerCase()));
  - const existingFile = existingRules.find((r) => r.filename.toLowerCase() === filename.toLowerCase());

- **TypeScript Utility Types**: Use TypeScript utility types like ReturnType<> when appropriate to avoid duplicating type definitions. This maintains type safety while reducing redundancy.
  - export function getExistingRules(cwd?: string): ReturnType<typeof readExistingRules>
  - const timeoutId: ReturnType<typeof setTimeout> = setTimeout(...);

- **Buffer Type Handling**: When handling Node.js Buffer objects from process streams, explicitly type them as Buffer in event handlers. Use .toString() method to convert Buffer to string.
  - process.stdout.on('data', (data: Buffer) => {
  output += data.toString();
});
  - childProcess.stdout.on('data', (data: Buffer) => {
  const chunk = data.toString();
  stdout += chunk;
});

- **Unused Variable Naming**: Prefix unused variables and parameters with underscore (_) to indicate they are intentionally unused. ESLint is configured to ignore variables matching the pattern '^_'.
  - function example(_unusedParam: string, usedParam: number) { }
  - const [_first, _second, third] = array;

- **Object Destructuring with Defaults**: Use object destructuring with default values in function parameters for configuration objects. Extract multiple properties at once with sensible defaults.
  - const {
  outputDir,
  verbose = false,
  dryRun = false,
  cwd = process.cwd(),
} = config;
  - const { timeout = 300000, verbose = false, existingRules } = options;

- **Array Method Chaining**: Use array methods like map(), filter(), find() with arrow functions for concise data transformations. Chain methods when appropriate for readability.
  - const existingFilenames = new Set(
  existingRules.map((r) => r.filename.toLowerCase())
);
  - existingRulesContext = existingRuleFiles
  .map(file => `\n## ${file.filename}\n${file.content}`)
  .join('\n\n---\n');

